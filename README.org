#+OPTIONS: ^:{}
#+STARTUP: indent nolineimages
#+TITLE: tiny_ge
#+AUTHOR: Shigeto R. Nishitani
#+EMAIL:     (concat "shigeto_nishitani@mac.com")
#+LANGUAGE:  jp
# +OPTIONS:   H:4 toc:t num:2
#+OPTIONS:   toc:nil
#+TAG: Linux, exclusive_processing
#+TWITTER: off
# +SETUPFILE: ~/.emacs.d/org-mode/theme-readtheorg.setup

tiny_ge is a tiny grid engine like SGE.

* Usage
tiny_ge has a similar interface with SGE.
#+begin_example
> tge --help

qsub [shell]        # submit shell job
qstat               # show queue status
qdel [pid]          # delete job
qfinish [pid]       # finish forcely
#+end_example

When you qsub shell, test.s_23520 will be made.
#+begin_src shell
> qsub ve_lock_vasp.sh
> cat test.s23520
#!/bin/sh
while ! qsub 23520; do
  sleep 10
done

sh /home/.../ve_lock_vasp.sh

qfinish 23520
#+end_src
The job is queued in ~/.tge_test_jobs.txt as YAML format.

qstat will show the status like 'running'.
#+begin_example shell
> qstat
11670: 11702:   finished: /home/test/hello_world.sh
14735: 14764:   finished: /home/test/hello_world.sh
18515: 18545:   finished: /home/test2/ve_lock_vasp.sh
29533: 29562:   finished: /home/test2/ve_lock_vasp.sh
18648: 18678:    running: /home/test2/ve_lock_vasp.sh
27624: 27654:    waiting: /home/test/hello_world.sh
#+end_example

You may write the job in ve_lock_vasp.sh,
then the queue system will wait the finish of previous job
and will run the waiting job.

